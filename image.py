import os
import json
import math  # 添加 math 模块导入
from pathlib import Path
from nodes import SaveImage
import folder_paths
import requests
from PIL import Image
from io import BytesIO
import numpy as np
import time
import torch
import urllib.request

# 必要的常量定义
BOOLEAN = ("BOOLEAN", {"default": True})
CONFIG = {"indent": 2}

# 简化的日志处理
class Logger:
    @staticmethod
    def debug(msg): print(f"[DEBUG] {msg}")
    @staticmethod
    def error(msg): print(f"[ERROR] {msg}")

logger = Logger()

class BImageSaveWithExtraMetadata(SaveImage):
    def __init__(self):
        super().__init__()
        self.data_cached = None
        self.data_cached_text = None

    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "image": ("IMAGE",),
                "filename_prefix": ("STRING", {"default": "ComfyUI"}),
                "with_workflow": BOOLEAN,
            },
            "optional": {
                "metadata_extra": ("STRING", {"multiline": True, "default": json.dumps({
                  "Title": "Image generated by \u56b4\u6ce2\u8a2d\u8a08",
                  "Description": "More info: https://slas.cc",
                  "Author": "BOZOYAN",
                  "Software": "ComfyUI",
                  "Category": "StableDiffusion",
                  "Rating": 5,
                  "UserComment": "",
                  "Keywords": [""],
                  "Copyrights": "BOZO DESIGN",
                }, indent=CONFIG["indent"]).replace("\\/", "/"),
                }),
            },
            "hidden": {
                "prompt": "PROMPT",
                "extra_pnginfo": "EXTRA_PNGINFO",
            },
        }

    RETURN_TYPES = ("METADATA_RAW",)
    RETURN_NAMES = ("Metadata RAW",)
    OUTPUT_NODE = True
    CATEGORY = "BOZO/PIC"
    FUNCTION = "execute"

    def execute(self, image=None, filename_prefix="ComfyUI", with_workflow=True, metadata_extra=None, prompt=None, extra_pnginfo=None):
        data = {
            "result": [''],
            "ui": {
                "text": [''],
                "images": [],
            }
        }
        if image is not None:
            if with_workflow is True:
                extra_pnginfo_new = extra_pnginfo.copy()
                prompt = prompt.copy()
            else:
                extra_pnginfo_new = None
                prompt = None

            if metadata_extra is not None and metadata_extra != 'undefined':
                try:
                    metadata_extra = json.loads(metadata_extra)
                except Exception as e:
                    logger.error(f"Error parsing metadata_extra (it will send as string), error: {e}")
                    metadata_extra = {"extra": str(metadata_extra)}

                if isinstance(metadata_extra, dict):
                    for k, v in metadata_extra.items():
                        if extra_pnginfo_new is None:
                            extra_pnginfo_new = {}
                        extra_pnginfo_new[k] = v

            saved = super().save_images(image, filename_prefix, prompt, extra_pnginfo_new)
            data["ui"]["images"] = saved["ui"]["images"]

        else:
            logger.debug("Source: Empty on BImageSaveWithExtraMetadata")

        return data


class BImageYunSuan:
    def __init__(self):
        pass

    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "width": ("INT", {"default": 1280, "min": 1, "max": 10240}),
                "height": ("INT", {"default": 1280, "min": 1, "max": 10240}),
                "formula": ("STRING", {
                    "multiline": True, 
                    "default": "math.sqrt((1280 * 1280) / (width * height))"
                }),
            },
        }

    RETURN_TYPES = ("STRING",)
    RETURN_NAMES = ("result",)
    FUNCTION = "execute"
    CATEGORY = "BOZO"

    def execute(self, width, height, formula):
        try:
            # 创建本地变量供公式使用
            locals_dict = {"math": math, "width": width, "height": height}
            # 执行公式计算
            result = eval(formula, {"__builtins__": {}}, locals_dict)
            # 将结果转换为浮点数，保留1位小数，不四舍五入 修改尾部:1 数值保留一位小数
            result_str = str(float(str(result).split('.')[0] + '.' + str(result).split('.')[1][:1])) if '.' in str(result) else str(result)
            return (result_str,)
        except Exception as e:
            logger.error(f"计算公式错误: {e}")


class PicRun:
    def __init__(self):
        try:
            # 使用 os.path.join 构建路径，确保跨平台兼容性
            key_folder = os.path.join(os.path.dirname(__file__), 'key')
            # 确保 key 文件夹存在
            if not os.path.exists(key_folder):
                os.makedirs(key_folder, exist_ok=True)
                logger.error(f"创建 key 文件夹: {key_folder}")
                
            api_key_path = os.path.join(key_folder, 'modelscope_api_key.txt')
            # 检查文件是否存在
            if not os.path.exists(api_key_path):
                logger.error(f"API key 文件不存在: {api_key_path}")
                self.api_key = None
            else:
                with open(api_key_path, 'r') as f:
                    self.api_key = f.read().strip()
                if not self.api_key:
                    logger.error("API key 文件为空")
                    self.api_key = None
        except Exception as e:
            logger.error(f"读取 API key 文件失败: {str(e)}")
            self.api_key = None
        
        self.size_presets = {
            "1:1 (1240x1240)": (1240, 1240),
            "4:3 (1080x1440)": (1080, 1440),
            "3:4 (1440x1080)": (1440, 1080),
            "1:2 (872x1744)": (872, 1744),
            "2:1 (1744x872)": (1744, 872),
            "2:3 (960x1440)": (960, 1440),
            "3:2 (1440x960)": (1440, 960),
            "2:5 (720x1800)": (720, 1800),
            "5:2 (1800x720)": (1800, 720),
            "3:5 (960x1600)": (960, 1600),
            "5:3 (1600x960)": (1600, 960),
            "4:5 (1080x1350)": (1080, 1350),
            "5:4 (1350x1080)": (1350, 1080),
            "9:16 (900x1600)": (900, 1600),
            "16:9 (1600x900)": (1600, 900),
        }

    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "model": ("STRING", {"default": "bozoyan/F_feifei"}),
                "prompt": ("STRING", {
                    "multiline": True,
                    "default": "A woman in a purple lace bra and pant is sitting on a bed."
                }),
                "steps": ("INT", {"default": 20, "min": 8, "max": 100}),
                "guidance": ("FLOAT", {"default": 3.5, "min": 1.5, "max": 20.0}),
                "sampler": (["DPM++ SDE", "DPM++ SDE Karras", "DPM++ 2M SDE", "DPM++ 2M Karras", "LCM", "DPM2 a", "Euler a", "Euler", "DDIM Normal"], {"default": "Euler"}),
                "size_preset": (["自定义", "1:1 (1240x1240)", "4:3 (1080x1440)", "3:4 (1440x1080)",
                "1:2 (872x1744)", "2:1 (1744x872)",
                "2:3 (960x1440)", "3:2 (1440x960)", "2:5 (720x1800)",
                "5:2 (1800x720)", "3:5 (960x1600)", "5:3 (1600x960)",
                "4:5 (1080x1350)", "5:4 (1350x1080)", "9:16 (900x1600)",
                "16:9 (1600x900)"], ),
                "width": ("INT", {"default": 1080, "min": 64, "max": 2400}),
                "height": ("INT", {"default": 1440, "min": 64, "max": 2400}),
                "seed": ("INT", {"default": 42, "min": 0, "max": 2147483647}),
            }
        }

    RETURN_TYPES = ("IMAGE", "STRING", "STRING", "INT", "FLOAT", "STRING", "INT", "INT", "INT", "STRING")
    RETURN_NAMES = ("image", "image_url", "model", "steps", "guidance", "sampler", "width", "height", "seed", "prompt")
    FUNCTION = "execute"
    CATEGORY = "BOZO"

    def _download_image(self, url):
        """从URL下载图像并转换为tensor"""
        try:
            response = urllib.request.urlopen(url)
            image_data = response.read()
            image = Image.open(BytesIO(image_data)).convert('RGB')
            
            # 转换为tensor格式 [H, W, 3]
            img_tensor = torch.tensor(list(image.getdata())).reshape(image.height, image.width, 3).float() / 255.0
            
            # 添加批次维度 [1, H, W, 3]
            return img_tensor.unsqueeze(0)
        except Exception as e:
            logger.error(f"下载图像时出错: {e}")
            return None

    def execute(self, model, prompt, steps, guidance, sampler, size_preset, width, height, seed):
        # 打印关键信息
        print("=" * 80)
        print(f"所属模型: {model} 采样：{sampler} CFG:{guidance} 步数: {steps} 图片尺寸: {size_preset}")
        print(f"提示词: {prompt}")
        print("=" * 80)

        if self.api_key is None:
            logger.error("无法读取 API key")
            # 返回空图像和错误信息
            empty_image = torch.zeros((1, 64, 64, 3))
            return (empty_image, "错误: 无法从 modelscope_api_key.txt 读取有效的 token", "", 0, 0.0, "", 0, 0, 0, "")
            
        if size_preset != "自定义":
            width, height = self.size_presets[size_preset]
        
        negative_prompt = "lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry,(worst quality:2),(low quality:2),(normal quality:2),lowres,normal quality,((monochrome)),((grayscale)),skin spots,acnes,skin blemishes,age spot,(ugly:1.33),(duplicate:1.33),(morbid:1.21),(mutilated:1.21),(tranny:1.33),mutated hands,(poorly drawn hands:1.5),blurry,(bad anatomy:1.21),(bad proportions:1.33),extra limbs,(disfigured:1.33),(missing arms:1.33),(extra legs:1.33),(fused fingers:1.61),(too many fingers:1.61),(unclear eyes:1.33),lowers,bad hands,missing fingers,extra digit,bad hands,missing fingers,(((extra arms and legs))),DeepNegativeV1.x_V175T,EasyNegative,EasyNegativeV2,"

        payload = {
            'model': model,
            'prompt': prompt,
            'negative_prompt': negative_prompt,
            'steps': steps,
            'guidance': guidance,
            'sampler': sampler,
            'size': f'{width}x{height}',
            'seed': seed
        }

        headers = {
            'Authorization': f'Bearer {self.api_key}',
            'Content-Type': 'application/json'
        }

        try:
            import time
            start_time = time.time()
            
            response = requests.post(
                'https://api-inference.modelscope.cn/v1/images/generations',
                data=json.dumps(payload, ensure_ascii=False).encode('utf-8'),
                headers=headers
            )
            response_data = response.json()
            
            # 计算渲染时间
            render_time = time.time() - start_time
            
            # 检查响应状态
            if 'images' not in response_data or not response_data['images']:
                error_msg = response_data.get('message', '未知错误')
                logger.error(f"API 返回错误: {error_msg}")
                empty_image = torch.zeros((1, 64, 64, 3))
                return (empty_image, f"API 调用失败: {error_msg}", "", 0, 0.0, "", 0, 0, 0, "")

            image_url = response_data['images'][0]['url']
            
            # 打印 URL 和渲染时间
            print(f"\n生成图片 URL: {image_url}")
            print(f"渲染耗时: {render_time:.2f} 秒\n")
            
            # 下载图像并转换为tensor
            print("正在下载图像...")
            image_tensor = self._download_image(image_url)
            
            if image_tensor is None:
                logger.error("图像下载失败")
                empty_image = torch.zeros((1, 64, 64, 3))
                return (empty_image, image_url, model, steps, guidance, sampler, width, height, seed, prompt)
            
            print(f"图像下载成功，尺寸: {image_tensor.shape}")
            
            return (image_tensor, image_url, model, steps, guidance, sampler, width, height, seed, prompt)
            
        except Exception as e:
            logger.error(f"API 调用错误: {e}")
            empty_image = torch.zeros((1, 64, 64, 3))
            return (empty_image, f"API 调用错误: {str(e)}", "", 0, 0.0, "", 0, 0, 0, "")
